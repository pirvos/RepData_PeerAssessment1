---
title: "Reproducible Research: Peer Assessment 1"
output: 
  html_document:
    keep_md: true
---

## Introduction
This work is aimed to analyze data as established in specifications for Project 1
in Course 5 of the Data Science track at Coursera. The data used is originally 
located in
file _activity.zip_, which is part of the following github repo: 
https://github.com/rdpeng/RepData_PeerAssessment1.

The general information about the system being used is displayed next. 
```{r general information about system} 
sessionInfo()
```

Other packages that shall be used are _dplyr_ and _lubridate_.

Now let's work. 

## Loading and preprocessing the data
The data to be proceesed is originally in file _activity.csv_, which is assumed
to be part of the current working directory. The data is read into a data frame 
named _activity_. For that, the following R code is used: 

```{r reading data, echo = TRUE}
activity <- read.csv("activity.csv")
```

The following are some initial exploratory operations to better understand the 
data. 

Dimensions of the data are: 
```{r dimensions of data}
dimsactivity <- dim(activity)
print(paste("Number of rows =", dimsactivity[1]))
print(paste("Number of columns =", dimsactivity[2]))
```

Number of observations per day are: 
```{r}
library(dplyr)
gactivityDate <- group_by(activity, date)
dataPerDay <- dplyr::summarise(gactivityDate, count = n())
nobs <- unique(dataPerDay$count)
if(length(nobs) == 1) {
      print(paste("There are ", nobs[1], 
                  " observations for each day in the data set."))
      n = 24*60/5
      if(nobs[1]==n)
            print("This is exactly the number of 5-minute intervals in 24 hours.")
      else 
            print(paste("The number of 5-minute intervals in 24 hours is", n, "."))
} else {
      print("Observations per day differ. Some of those numbers are:")
      print(nobs)
}
```


## What is mean total number of steps taken per day?
The following R code constructs a histogram of the number of steps taken per day. 
The
intervals being used are as determined by the value of parameter _breaks_ that
R assigns by default. Different histograms
can be generated by just adding the corresponding "breaks" value. The _mean_ and 
the _median_ of the total number of steps taken per day are also shown. 
```{r}
library(dplyr)
gactivityDate <- group_by(activity, date)
sactivityDate <- 
      dplyr::summarise(gactivityDate, totalSteps = sum(steps, na.rm = TRUE))
h <- hist(sactivityDate$totalSteps, plot = FALSE)
plot(h, main="Distribution of Total Steps Taken on Each Day", 
     ylim = c(0, max(h$counts)+5), ylab = "Frequency (Number of days)", 
     xlab = "Total Number of Steps Per Day", col = "gray", labels = TRUE)
md <- round(median(sactivityDate$totalSteps), 2)
mn <- round(mean(sactivityDate$totalSteps), 2)
abline(v=md, col = "red", lwd=2)
abline(v=mn, col="blue", lwd=2)
legend("topright", lty=1, lwd=2, legend=c(paste("median = ", md), 
                                     paste("mean = ", mn)), 
                                     col = c("red", "blue"))

```



## What is the average daily activity pattern?
To explore the average daily activity, we want to determine the average number 
of steps taken on each 5-minute interval. For this, we will do the following: 

1. Make a time series plot of the 5-minute intervals (x-axis) and the average 
number of steps taken, averaged across all days (y-axis). 

2. Show the 5-minute interval, on average across all the days in the data set, 
containing the maximun number of steps. If more than one, it shows all the
corresponding intervals.

The following R code constructs and diplays the plot described in 1. It also 
shows the _mean_ and the _median_ for the average number of steps per 5-minute
interval. 
```{r}
library(dplyr)
gactivityInterval <- group_by(activity, interval)
sactivityInterval <- 
      dplyr::summarise(gactivityInterval, 
                       averageSteps = mean(steps, na.rm = TRUE))
sactivityInterval$intervalNumber <- 1:nrow(sactivityInterval)
plot(sactivityInterval$intervalNumber, sactivityInterval$averageSteps, 
     type = "l", lwd=2, xlab = "5-minute Interval in a Day", 
     ylab = "Average Number of Steps in Interval")
md <- round(median(sactivityInterval$averageSteps), 2)
mn <- round(mean(sactivityInterval$averageSteps), 2)
abline(h=md, col = "red")
abline(h=mn, col="blue")
title(main="Average Number of Steps Per 5-minute Interval Across All Days")
legend("topright", lty=1, lwd=2, legend=c(paste("median = ", md), 
                                     paste("mean = ", mn)), 
                                     col = c("red", "blue"))
```

The following produces the 5-minute period(s) containing the maximum number of 
steps. 
```{r}
library(lubridate)
maxSteps <- max(sactivityInterval$averageSteps)
maxStepsPeriod <- subset(sactivityInterval, averageSteps == maxSteps)
print(paste("The 5-minute period with maximum average number of steps is: interval", 
            maxStepsPeriod$intervalNumber))
h <- maxStepsPeriod$interval
print(paste("It corresponds to the hour: ", 
            hm(paste(trunc(h/100), h%%100, sep = ":"))))


```


## Imputing missing values

At this stage, we want to estimate and add values to those missing values in the 
original data set. We can use the following loop to count how many rows contain 
NA values for each 
variable in the data frame.
```{r}
nm <- names(activity)
for(v in 1:length(nm)) { 
      nmv <- sum(is.na(activity[, v]))  
      if (nmv > 0) 
            print(paste("Variable", nm[v], "has ", nmv, "missing values."))
}
```
We can see that only variable _steps_ has missing values. In total, there are
2304 missing values of that variable. 

To assign a value to each of those observations in which the value of the 
variable _steps_ is missing, what we will do is the following. 
To each 5-minute period p for a particular day x in which the value of _steps_ 
is 
NA, we will assign the current average number
of steps taken across all instances in the data set corresponding to the same 
day of 
the week as day x and same period p discarting the NA values. In those cases 
(if any) in which all the values are
missing, we shall assign value 0. 

First, we add a new column with values 1..7, identifying the day of the week 
that each registered date corresponds to. The name of the new column 
is _wdayNumber_
and it is of type _integer_. This is achieved with the following R code: 
```{r adding column for days}
library(lubridate)
activity$wdayNumber <- wday(activity$date)   ## 1 Sunday, 2 Monday, ... 7  Sat
```

The next R code constructs a temporary data frame containing the estimaded
values to substitute the NA values as per the previously described strategy. 
The new data frame's name is _sactivityWDayInterval_, in which 
column _missingSteps_ contain the estimated value for the 5-minute interval that 
the particular row corresponds to. The displayed result shows tha no estimated
value is NA. 
```{r}
gactivityWDayInterval <- group_by(activity, wdayNumber, interval)
sactivityWDayInterval <- 
      dplyr::summarise(gactivityWDayInterval, 
                       missingSteps = mean(steps, na.rm = TRUE))
print(paste("Number of NA values in missingSteps is:",
      sum(is.na(sactivityWDayInterval$missingSteps))))
```

Note that there is an estimated missing value for every period on each different
day of the week. That is, there are 288*7=2016 rows in the new data frame. 
```{r}
dim(sactivityWDayInterval)
```

For each row in the _activity_ data frame in
which the number of steps is NA as per the original data, we assign the missing
value that was computed for such period and the particular day of the week 
that the row corresponds to. For this, the 
following R code is executed. 

```{r}
activity2 <- merge(activity, sactivityWDayInterval)
naStepIndexes <- is.na(activity2$steps)
activity2[naStepIndexes,]$steps <- activity2[naStepIndexes,]$missingSteps
activity$missingSteps <- NULL
```

Now, the following code is used to make a histrogram of the total number of steps
taken each day, and to report the mean and the median of total number of steps
taken per day after adding estimated values for those that were missing. 

```{r}
library(dplyr)
gactivityDate <- group_by(activity2, date)
sactivityDate <- dplyr::summarise(gactivityDate, 
                                  totalSteps = sum(steps, na.rm = TRUE))
h <- hist(sactivityDate$totalSteps, plot = FALSE)
plot(h, 
     main="Distribution of Total Steps Taken on Each Day 
     After Adding Missing Values", 
     ylim = c(0, max(h$counts)+1), ylab = "Frequency (Number of days)", 
     xlab = "Total Number of Steps Per Day", col = "gray", labels = TRUE)
md <- round(median(sactivityDate$totalSteps), 2)
mn <- round(mean(sactivityDate$totalSteps), 2)
abline(v=md, col = "red", lwd=2)
abline(v=mn, col="blue", lwd=2)
legend("topright", lty=1, lwd=2, legend=c(paste("median = ", md), 
                                     paste("mean = ", mn)), 
                                     col = c("red", "blue"))
```


## Are there differences in activity patterns between weekdays and weekends?
Now let's add a new column to the _activity2_ data frame. This is a column of 
type 
_factor_ and two levels: _weekend_ and _weekday_. It classifies each of the 
observations in the  _activity2_ data frame depending to the day of the week 
that its date corresponds to. 
```{r adding new factor attribute for days: dayType }
library(lubridate)
weekendDays <- activity2$wdayNumber == 1 | activity2$wdayNumber == 7
activity2$dayType <- "weekday"
activity2[weekendDays,]$dayType = "weekend"
activity2$dayType <- as.factor(activity2$dayType)
```
And verifying how many of the observations belongs to each of the two categories, 
we get the following: 
```{r count observations in each of the two categories} 
table(activity2$dayType)
```

To compare patterns in weekdays vs weekends we generate the next two plots, one
for week days (Monday trhough Friday) and another for weekend days. In both, the 
plot shows the average number of steps per 5-minute periods during the day. Data 
used is the data in _activity2_, which include the estimated values for those 
that were missing in the original data. 
```{r} 
library(lattice)
library(dplyr)
gactivityDaytypeInterval <- group_by(activity2, dayType, interval)
sactivityDaytypeInterval <- dplyr::summarise(gactivityDaytypeInterval, 
                                             average=mean(steps, 
                                                          na.rm = TRUE))
sactivityDaytypeInterval$intervalNumber <- 
      rep(1:(nrow(sactivityDaytypeInterval)/2), 2)

with(sactivityDaytypeInterval, 
     xyplot(average~intervalNumber|dayType, type = "l", col="black", 
            panel = function(x, y) { 
                  lcolor <- c("red", "blue")
                  panel.xyplot(x, y, type = "l", col = "black")
                  panel.abline(h=median(y), col=lcolor[1], lty=2)  ## median
                  panel.abline(h=mean(y), col=lcolor[2], lty=2)  ## mean
                  
                  # adding a legend to each panel
                  infText1 <- paste("--- median =", round(median(y),2))
                  infText2 <- paste("--- mean = ", round(mean(y),2))
                  panel.text(220, 230, labels=c(infText1, 1),  col=lcolor[1]) 
                  panel.text(220, 215 , labels=c(infText2, 2),  col=lcolor[2]) 
            },
            xlab = "5-minute Interval", 
            ylab = "Average Number of Steps")
     )

```

In each case, the _horizontal line in red_ is the line of _median_ value of the _average number of steps_ for the particular category represented in the panel, 
while the _blue line_ corresponds to its _mean_. 