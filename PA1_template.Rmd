---
title: "Reproducible Research: Peer Assessment 1"
output: 
  html_document:
    keep_md: true
---

## Introduction
This work is aimed to analyze data as established in specifications for Project 1
in Course 5 of the Data Science track at Coursera. The specifications, as well 
as the data, are
part of the following github repo: 
https://github.com/rdpeng/RepData_PeerAssessment1. In that repo, the
specifications are in 
file _README.md_, and the data to be analyzed is in file _activity.zip_. The
data file was downloaded  and decompressed (by "hand") into the current working
directory.

The general information about the system being used is displayed next. 
```{r general information about system} 
sessionInfo()
```

Other packages that shall be used are _dplyr_, _lubridate_, and _lattice_.

Now let's work. 

## Loading and preprocessing the data
Once the zip file is downloaded and decompressed, we get access to file 
_activity.csv_, which contains the data to be analyzed. From now on, the 
analysis to be presented here presumes that file _activity.csv_ is located
in the current working directory. 

The data in _activity.csv_ is read into a data frame 
named _activity_. For that, the following R code is used: 

```{r reading data, echo = TRUE}
activity <- read.csv("activity.csv")
```

The following are some initial exploratory operations to better understand the 
data. 

Dimensions of the data are: 
```{r dimensions of data}
dimsactivity <- dim(activity)
print(paste("Number of rows =", dimsactivity[1]))
print(paste("Number of columns =", dimsactivity[2]))
```

There is one row for every 5-minute period in all the days in the data
set. The following R code is used to certify this. 
```{r}
library(dplyr)
gactivityDate <- group_by(activity, date)
dataPerDay <- dplyr::summarise(gactivityDate, count = n())
nobs <- unique(dataPerDay$count)
if(length(nobs) == 1) {
      print(paste("There are ", nobs[1], 
                  " observations for each day in the data set."))
      n = 24*60/5
      if(nobs[1]==n)
            print("This is exactly the number of 5-minute intervals in 24 hours.")
      else 
            print(paste("The number of 5-minute intervals in 24 hours is", n, "."))
} else {
      print("Observations per day differ. Some of those numbers are:")
      print(nobs)
}
```


## What is mean total number of steps taken per day?
The following R code constructs a histogram of the number of steps taken per day. 
The
intervals being used are as determined by the value of parameter _breaks_ that
R assigns by default. Different histograms
can be generated by just adding the corresponding "breaks" value. The _mean_ and 
the _median_ of the total number of steps taken per day are also shown in the 
histogram panel as lines, as well as values. 
```{r}
library(dplyr)
## determine the total number of steps taken on each day in the data set
## these totals are saved in data frame sactivityDate
gactivityDate <- group_by(activity, date)
sactivityDate <- 
      dplyr::summarise(gactivityDate, totalSteps = sum(steps, na.rm = TRUE))
h <- hist(sactivityDate$totalSteps, plot = FALSE)
plot(h, main="Distribution of Total Steps Taken on Each Day", 
     ylim = c(0, max(h$counts)+5), ylab = "Frequency (Number of days)", 
     xlab = "Total Number of Steps Per Day", col = "gray", labels = TRUE)
md <- round(median(sactivityDate$totalSteps), 2)  # median of total steps per day
mn <- round(mean(sactivityDate$totalSteps), 2)    # mean of total steps per day
abline(v=md, col = "red", lwd=2)  # display horizontal line for median
abline(v=mn, col="blue", lwd=2)   # display horizontal line for mean
legend("topright", lty=1, lwd=2, legend=c(paste("median = ", md), 
                                     paste("mean = ", mn)), 
                                     col = c("red", "blue"))
```



## What is the average daily activity pattern?
To explore the average daily activity, we want to determine the average number 
of steps taken on each 5-minute interval. For this, we will do the following: 

1. Make a time series plot of the 5-minute intervals (x-axis) and the average 
number of steps taken, averaged across all days (y-axis). 

2. Show the 5-minute interval, on average across all the days in the data set, 
containing the maximun number of steps. If more than one, it shows all the
corresponding intervals.

The following R code constructs and diplays the plot described in 1. It also 
shows the _mean_ and the _median_ for the average number of steps per 5-minute
interval. The 5-minute intervals are numbered 1, 2, ..., 288, from the first
5-minute period of the day to the last. Two histograms are shown, one using 
this interval number (1..288) and another using the interval number as included
in the original data set. 
```{r}
library(dplyr)
## determine the average number of steps taken on each 5-minute interval
## accross all days in the data set and discarding missing values
## These averages are computed in data frame sactivityInterval
gactivityInterval <- group_by(activity, interval)
sactivityInterval <- 
      dplyr::summarise(gactivityInterval, 
                       averageSteps = mean(steps, na.rm = TRUE))
## assign index value 1..288 to each 5-minute interval
sactivityInterval$intervalNumber <- 1:nrow(sactivityInterval)
plot(sactivityInterval$intervalNumber, sactivityInterval$averageSteps, 
     type = "l", lwd=2, xlab = "5-minute Interval in a Day", 
     ylab = "Average Number of Steps in Interval")
md <- round(median(sactivityInterval$averageSteps), 2)
mn <- round(mean(sactivityInterval$averageSteps), 2)
abline(h=md, col = "red")
abline(h=mn, col="blue")
title(main="Average Number of Steps Per 5-minute Interval Across All Days")
legend("topright", lty=1, lwd=2, legend=c(paste("median = ", md), 
                                     paste("mean = ", mn)), 
                                     col = c("red", "blue"))
```

```{r}
## same as previous chunk, but this time the x-axis uses labels corresponding
## to the values of interval as in the data set, not indexes 1:288 as in that
## chunk.
plot(sactivityInterval$interval, sactivityInterval$averageSteps, 
     type = "l", lwd=2, xlab = "5-minute Interval in a Day", 
     ylab = "Average Number of Steps in Interval")
md <- round(median(sactivityInterval$averageSteps), 2)
mn <- round(mean(sactivityInterval$averageSteps), 2)
abline(h=md, col = "red")
abline(h=mn, col="blue")
title(main="Average Number of Steps Per 5-minute Interval Across All Days")
legend("topright", lty=1, lwd=2, legend=c(paste("median = ", md), 
                                     paste("mean = ", mn)), 
                                     col = c("red", "blue"))
```

The following produces the 5-minute period(s) containing the maximum number of 
steps. 
```{r}
library(lubridate)
maxSteps <- max(sactivityInterval$averageSteps)
maxStepsPeriod <- subset(sactivityInterval, averageSteps == maxSteps)
print(paste("The 5-minute period with maximum average number of steps is: interval", 
            maxStepsPeriod$intervalNumber))
print(paste("This corresponds to the following interval as in the original data:", 
            maxStepsPeriod$interval))
h <- maxStepsPeriod$interval
print(paste("In both cases, the hour of the day with that maximum value is: ", 
            hm(paste(trunc(h/100), h%%100, sep = ":"))))
print(paste("The maximum average number of steps per period is: ", round(maxSteps, 2)))
```


## Imputing missing values

At this stage, we want to estimate and add values to those missing values in the 
original data set. We can use the following loop to count how many rows contain 
NA values for each 
variable in the data frame.
```{r}
nm <- names(activity)
for(v in 1:length(nm)) { 
      nmv <- sum(is.na(activity[, v]))  
      if (nmv > 0) 
            print(paste("Variable", nm[v], "has ", nmv, "missing values."))
}
```
We can see that only variable _steps_ has missing values. In total, there are
2304 missing values of that variable. 

To assign a value to all those observations in which the value of the 
variable _steps_ is missing, what we will do is the following. 
To the 5-minute period p for a particular day x in which the value of _steps_ 
is 
NA, we will assign the current average number
of steps taken across all instances in the data set corresponding to the same 
day of 
the week as day x and same period p after discarting the NA values. 
In those cases 
(if any) in which all the values are
missing, we shall assign value 0. 

First, we add a new column to _activity_ data frame. Such column will have 
values 1..7, identifying the _day of the week_ that the particular observation
corresponds to as per the value of _date_.  The name of the new column 
is _wdayNumber_
and it is of type _integer_. This is achieved with the following R code: 
```{r adding column for days}
library(lubridate)
activity$wdayNumber <- wday(activity$date)   ## 1 Sunday, 2 Monday, ... 7  Sat
```

The next R code constructs a temporary data frame containing the estimaded
values to substitute the NA values as per the previously described strategy. 
The new data frame's name is _sactivityWDayInterval_, in which 
column _missingSteps_ contains the estimated value for the 5-minute interval that 
the particular row corresponds to. The displayed result shows tha no estimated
value is NA. 
```{r}
gactivityWDayInterval <- group_by(activity, wdayNumber, interval)
sactivityWDayInterval <- 
      dplyr::summarise(gactivityWDayInterval, 
                       missingSteps = mean(steps, na.rm = TRUE))
print(paste("Number of NA values in missingSteps is:",
      sum(is.na(sactivityWDayInterval$missingSteps))))
```

Note that there is an estimated missing value for every period on each different
day of the week. That is, there are 288*7=2016 rows in the new data frame. 
```{r}
dim(sactivityWDayInterval)
```

For each row in the _activity_ data frame in
which the number of steps is NA as per the original data, we assign the missing
value that was computed for such period and the particular day of the week 
that the row corresponds to. This new version of the data is saved in a new
data frame called
_actividy2_. The 
following R code does it. 

```{r}
activity2 <- merge(activity, sactivityWDayInterval)
naStepIndexes <- is.na(activity2$steps)
activity2[naStepIndexes,]$steps <- activity2[naStepIndexes,]$missingSteps
activity$missingSteps <- NULL
```

Using the new data, which include the estimated values, the next code makes 
a _histrogram of the total number of steps
taken each day_, and  reports its _mean_ and  _median_ values 
after adding estimated values for those that were missing. 

```{r}
library(dplyr)
gactivityDate <- group_by(activity2, date)
sactivityDate <- dplyr::summarise(gactivityDate, 
                                  totalSteps = sum(steps, na.rm = TRUE))
h <- hist(sactivityDate$totalSteps, plot = FALSE)
plot(h, 
     main="Distribution of Total Steps Taken on Each Day 
     After Adding Missing Values", 
     ylim = c(0, max(h$counts)+1), ylab = "Frequency (Number of days)", 
     xlab = "Total Number of Steps Per Day", col = "gray", labels = TRUE)
md <- round(median(sactivityDate$totalSteps), 2)
mn <- round(mean(sactivityDate$totalSteps), 2)
abline(v=md, col = "red", lwd=2)
abline(v=mn, col="blue", lwd=2)
legend("topright", lty=1, lwd=2, legend=c(paste("median = ", md), 
                                     paste("mean = ", mn)), 
                                     col = c("red", "blue"))
```

As can be observed from the output graphs, there is substantial change in those
days in which less than 15,000 steps were taken. The new data increases the 
values of mean and median of the total number of steps taken on each day when 
compared to the orinal data in which the missing values were discarded. 

After noticing that the distribution did not change for those days in 
which at least one of the 288 5-minute periods have NA as the value of
variable _steps_, I decided to explore this further. I will try to answer the
following question: Where were the original NA values? For this, I generated the
following R code to discover which days were reporting those missing values. 

```{r}
daysWithNASteps <- subset(activity, is.na(steps))
gdaysWithNAStepsDate <- group_by(daysWithNASteps, date)
sdaysWithNASteps <- dplyr::summarise(gdaysWithNAStepsDate, countNAPeriods = n())
sdaysWithNASteps
```

As we can see, only 8 days are reported. Moreover, in all those days, all 5-minute
periods have missing value for variable _steps_. Hence, in the original data, 
these were part of the 13 days shown for the interval [0, 5000]. This is so 
because the expression _sum(x, na.rm=TRUE)_ returns 0 if all entries in x are NA.

Notice also 
that in the new histogram (after adding the estimated values), there are only 5
days in the range [0, 5000]. This means that the estimated values put all those 
8 days in one of the following ranges: [5000, 10000] or [10000, 15000]. We can
explore this in more detail by using the following R code. 

```{r}
daysOfEstimatedSteps <- 
      subset(activity2, is.element(date, sdaysWithNASteps$date))
gdaysOESDate <- group_by(daysOfEstimatedSteps, date)
sdaysOESDate <- dplyr::summarise(gdaysOESDate, totalSteps = sum(steps))
sdaysOESDate
```

And here we can see what really happened after adding the estimated number
of steps to those 5-minute periods having NA value for variable _steps_. Note 
that _three_ of them now are in the range [5000, 10000] and _five_ are in the 
range [10000, 15000]. That explains why the original histogram (when NA values
were discarded) changes to
the new one after the missing values are estimated. 

## Are there differences in activity patterns between weekdays and weekends?
Now let's add a new column to the _activity2_ data frame. This is a column of 
type 
_factor_ and two levels: _weekend_ and _weekday_. It classifies each of the 
observations in the  _activity2_ data frame depending to the day of the week 
that its date corresponds to. 
```{r adding new factor attribute for days: dayType }
library(lubridate)
weekendDays <- activity2$wdayNumber == 1 | activity2$wdayNumber == 7
activity2$dayType <- "weekday"
activity2[weekendDays,]$dayType = "weekend"
activity2$dayType <- as.factor(activity2$dayType)
```
And verifying how many of the observations belongs to each of the two categories, 
we get the following: 
```{r count observations in each of the two categories} 
table(activity2$dayType)
```

To compare patterns in weekdays vs weekends we generate the next two plots, one
for week days (Monday trhough Friday) and another for weekend days. In both, the 
plot shows the average number of steps per 5-minute periods during the day. Data 
used is the data in _activity2_, which include the estimated values for those 
that were missing in the original data. 
```{r} 
library(lattice)
library(dplyr)
gactivityDaytypeInterval <- group_by(activity2, dayType, interval)
sactivityDaytypeInterval <- dplyr::summarise(gactivityDaytypeInterval, 
                                             average=mean(steps, 
                                                          na.rm = TRUE))
sactivityDaytypeInterval$intervalNumber <- 
      rep(1:(nrow(sactivityDaytypeInterval)/2), 2)

with(sactivityDaytypeInterval, 
     xyplot(average~intervalNumber|dayType, type = "l", col="black", 
            panel = function(x, y) { 
                  lcolor <- c("red", "blue")
                  panel.xyplot(x, y, type = "l", col = "black")
                  panel.abline(h=median(y), col=lcolor[1], lty=2)  ## median
                  panel.abline(h=mean(y), col=lcolor[2], lty=2)  ## mean
                  
                  # adding a legend to each panel
                  infText1 <- paste("--- median =", round(median(y),2))
                  infText2 <- paste("--- mean = ", round(mean(y),2))
                  panel.text(220, 230, labels=c(infText1, 1),  col=lcolor[1]) 
                  panel.text(220, 215 , labels=c(infText2, 2),  col=lcolor[2]) 
            },
            xlab = "5-minute Interval", 
            ylab = "Average Number of Steps")
     )
```

The values, as well as corresponding horizontal lines, for the median and the 
mean are included in the corresponding panel. 